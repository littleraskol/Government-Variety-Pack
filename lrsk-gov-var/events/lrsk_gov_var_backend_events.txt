# Government Variety Pack
# Events - Backend
# Author: littleraskol

# These events serve some general utility function.

namespace = lrsk_government_variety_pack_backend

# Adds a flag denoting this mod is in use, starts up mod-added origins.
event = {
	id = lrsk_government_variety_pack_backend.1
	hide_window = yes
	is_triggered_only = yes
	
	#trigger = { NOT = { has_global_flag = lrsk_government_variety_pack_mod_active } } 
	
	immediate = {
		set_global_flag = lrsk_government_variety_pack_mod_active
		
		## Origins Setup

		# Fed start fix for GVP govs
		every_playable_country = {
			limit = {
				is_gestalt = no # probably unneeded but eh
				has_federation = yes # This is real JIC shit
				OR = {
					has_origin = origin_common_ground
					has_origin = origin_hegemon
				}
				is_authoritarian = no
				is_egalitarian = no
				lrsk_has_any_gvp_gov = yes
			}
			country_event = { id = lrsk_gov_var_galactic_backdoor.4 days = 1 }
		}

		# Galactic Backdoor
		every_playable_country = {
			limit = { has_origin = lrsk_gov_var_origin_galactic_backdoor }
			country_event = { id = lrsk_gov_var_galactic_backdoor.1 }
		}
		
		# Shroud-Touched
		every_playable_country = {
			limit = { has_origin = lrsk_gov_var_origin_shroud_touched }
			country_event = { id = lrsk_gov_var_shroud_touched.1 }
		}
		
		# For Discovery / Tradeways / Grand Alliance
		every_playable_country = {
			limit = { OR = { 
				has_origin = lrsk_gov_var_origin_for_discovery
				has_origin = lrsk_gov_var_origin_for_discovery_mi
				has_origin = lrsk_gov_var_origin_tradeways
				has_origin = lrsk_gov_var_origin_tradeways_mc
				has_origin = lrsk_gov_var_origin_grand_alliance
			} }
			country_event = { id = lrsk_gov_var_new_fed_starts.1 }
		}
	}
}

# Fix for other mods possibly removing deposits. Should avoid the need for compatibility patches, etc.
# Every event that adds a starting planetary feature to the capital should call this to run after 2 days.
country_event = {
	id = lrsk_government_variety_pack_backend.2
	is_triggered_only = yes
	hide_window = yes

	# Structurally, this trigger is set up to facilitate adding "origin + flag" blocks. May be logically redundant but better safe than sorry...
	# Flags referred to here may not be used elsewhere but are pre-emptively checked in case I ever decide to add deposit-removing events, etc.
	trigger = {
		OR = {
			AND = {
				has_origin = lrsk_gov_var_origin_shroud_touched
				NOT = { has_country_flag = lrsk_gov_var_shroud_touched_lost_otherworld_pockets }
			}
			# Add other checks as needed...
		}
	}

	immediate = {
		# Most of these will check on capitals, since that's the most likely place for mod-added features.
		capital_scope = {
			switch = {
				trigger = has_planet_flag
				# Restore Otherworld Pockets if removed
				lrsk_gov_var_shroud_touched_capital = {
					IF = { limit = { NOT = { has_deposit = d_lrsk_gov_var_shroud_pockets } }
						add_deposit = d_lrsk_gov_var_shroud_pockets
					}
				}
				# Add other planet flags as needed...
			}
		}
	}
}

# Make sure that for origins that spawn new nearby empires, unlikely to be boxed in completely
country_event = {
	id = lrsk_government_variety_pack_backend.3
	is_triggered_only = yes
	hide_window = yes

	trigger = {
		OR = {
			has_origin = lrsk_gov_var_origin_for_discovery
			has_origin = lrsk_gov_var_origin_for_discovery_mi
			has_origin = lrsk_gov_var_origin_tradeways
			has_origin = lrsk_gov_var_origin_tradeways_mc
			has_origin = lrsk_gov_var_origin_grand_alliance
			#has_origin = lrsk_gov_var_origin_uplift 			# very unlikely but eh
			#has_origin = lrsk_gov_var_origin_sublight_empire
			#has_origin = lrsk_gov_var_origin_sublight_commonwealth
			#has_origin = lrsk_gov_var_origin_other
		}
	}
	
	immediate = {
		if = {
			limit = {
				capital_scope = {
					solar_system = {
						NOT = {
							any_neighbor_system = {
								NOT = { exists = owner }
							}
						}
					}
				}
			}
			if = {
				limit = {
					any_system = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 1
							max_distance <= 15
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
				}
				random_system = {
					limit = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 1
							max_distance <= 15
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
					save_event_target_as = lrsk_hyperlane_system_1
					add_hyperlane = {
						from = this
						to = root.capital_scope.solar_system
					}
				}
			}
			else_if = {
				limit = {
					any_system = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 15
							max_distance <= 20
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
				}
				random_system = {
					limit = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 15
							max_distance <= 20
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
					save_event_target_as = lrsk_hyperlane_system_1
					add_hyperlane = {
						from = this
						to = root.capital_scope.solar_system
					}
				}
			}
			else_if = {
				limit = {
					any_system = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 20
							max_distance <= 25
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
				}
				random_system = {
					limit = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 20
							max_distance <= 25
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
					save_event_target_as = lrsk_hyperlane_system_1
					add_hyperlane = {
						from = this
						to = root.capital_scope.solar_system
					}
				}
			}
			else_if = {
				limit = {
					any_system = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 25
							max_distance <= 40
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
				}
				random_system = {
					limit = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 25
							max_distance <= 40
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
					save_event_target_as = lrsk_hyperlane_system_1
					add_hyperlane = {
						from = this
						to = root.capital_scope.solar_system
					}
				}
			}
			if = { limit = { exists = event_target:lrsk_hyperlane_system_1 }
				event_target:lrsk_hyperlane_system_1 = {
					if = { limit = { NOT = { any_neighbor_system = { NOT = { exists = owner } } } }
						if = {
							limit = { any_system = {
								distance = {
									source = event_target:lrsk_hyperlane_system_1
									type = euclidean
									min_distance >= 1
									max_distance <= 25
								}
								NOT = { has_hyperlane_to = event_target:lrsk_hyperlane_system_1 }
								NOT = { exists = owner }
							} }
							random_system = {
								limit = { 
									distance = {
										source = event_target:lrsk_hyperlane_system_1
										type = euclidean
										min_distance >= 1
										max_distance <= 25
									}
									NOT = { has_hyperlane_to = this }
									NOT = { exists = owner }
								}
								save_event_target_as = lrsk_hyperlane_system_2
								add_hyperlane = {
									from = this
									to = event_target:lrsk_hyperlane_system_1
								}
							}
						}
						else_if = {
							limit = { any_system = {
								distance = {
									source = event_target:lrsk_hyperlane_system_1
									type = euclidean
									min_distance > 25
									max_distance <= 50
								}
								NOT = { has_hyperlane_to = event_target:lrsk_hyperlane_system_1 }
								NOT = { exists = owner }
							} }
							random_system = {
								limit = { 
									distance = {
										source = event_target:lrsk_hyperlane_system_1
										type = euclidean
										min_distance > 25
										max_distance <= 50
									}
									NOT = { has_hyperlane_to = event_target:lrsk_hyperlane_system_1 }
									NOT = { exists = owner }
								}
								save_event_target_as = lrsk_hyperlane_system_2
								add_hyperlane = {
									from = this
									to = event_target:lrsk_hyperlane_system_1
								}
							}
						}					
					}
				}
			}
			if = { limit = { exists = event_target:lrsk_hyperlane_system_2 }
				event_target:lrsk_hyperlane_system_2 = {
					if = { limit = { NOT = { any_neighbor_system = { NOT = { exists = owner } } } }
						if = {
							limit = { any_system = {
								distance = {
									source = event_target:lrsk_hyperlane_system_2
									type = euclidean
									min_distance >= 1
									max_distance <= 25
								}
								NOT = { has_hyperlane_to = event_target:lrsk_hyperlane_system_2 }
								NOT = { exists = owner }
							} }
							random_system = {
								limit = { 
									distance = {
										source = event_target:lrsk_hyperlane_system_2
										type = euclidean
										min_distance >= 1
										max_distance <= 25
									}
									NOT = { has_hyperlane_to = this }
									NOT = { exists = owner }
								}
								save_event_target_as = lrsk_hyperlane_system_3
								add_hyperlane = {
									from = this
									to = event_target:lrsk_hyperlane_system_1
								}
							}
						}
					}
				}					
			}
		}
	}
}

# Catches problem with base game fed starts checking for base game governments...
country_event = {
	id = lrsk_government_variety_pack_backend.4
	is_triggered_only = yes
	hide_window = yes

	trigger = {
		is_gestalt = no # probably unneeded but eh
		has_federation = yes # This is real JIC shit
		OR = {
			has_origin = origin_common_ground
			has_origin = origin_hegemon
		}
		is_authoritarian = no
		is_egalitarian = no
		lrsk_has_any_gvp_gov = yes
	}

	immediate = {
		if = {
			limit = { OR = {
				has_ethic = ethic_fanatic_pacifist
				AND = {
					has_ethic = ethic_pacifist
					has_ethic = ethic_fanatic_xenophile
				}
			} }
			set_country_flag = lrsk_fedfix_tag_pacifist
		}
		else_if = {
			limit = { OR = {
				has_ethic = ethic_fanatic_materialist
				AND = {
					has_ethic = ethic_materialist
					has_ethic = ethic_fanatic_xenophile
				}
			} }
			set_country_flag = lrsk_fedfix_tag_materialist
		}
		else_if = {
			limit = { OR = {
				has_ethic = ethic_fanatic_spiritualist
				AND = {
					has_ethic = ethic_spiritualist
					has_ethic = ethic_fanatic_xenophile
				}
			} }
			set_country_flag = lrsk_fedfix_tag_spiritualist
		}
		else_if = {
			limit = { OR = {
				has_ethic = ethic_fanatic_militarist
				AND = {
					has_ethic = ethic_militarist
					has_ethic = ethic_fanatic_xenophile
				}
			} }
			set_country_flag = lrsk_fedfix_tag_militarist
		}
		# This is a failsafe to get SOME matching ethos if none of the above apply...
		# ...which could happen with two non-fanatic of the above + xenophile.
		else_if = {
			limit = { OR = {
				has_ethic = ethic_pacifist
				has_ethic = ethic_spiritualist
				has_ethic = ethic_militarist
				has_ethic = ethic_materialist
			} }
			random_list = {
				1 = {
					modifier = {
						factor = 0
						NOT = { has_ethic = ethic_pacifist }
					}
					set_country_flag = lrsk_fedfix_tag_pacifist
				}
				1 = {
					modifier = {
						factor = 0
						NOT = { has_ethic = ethic_spiritualist }
					}
					set_country_flag = lrsk_fedfix_tag_spiritualist
				}
				1 = {
					modifier = {
						factor = 0
						NOT = { has_ethic = ethic_militarist }
					}
					set_country_flag = lrsk_fedfix_tag_militarist
				}
				1 = {
					modifier = {
						factor = 0
						NOT = { has_ethic = ethic_materialist }
					}
					set_country_flag = lrsk_fedfix_tag_materialist
				}
			}
		}

		# Dunno if we can reach this point without one of the flags but...
		IF = {
			limit = { OR = {
				has_country_flag = lrsk_fedfix_tag_pacifist
				has_country_flag = lrsk_fedfix_tag_spiritualist
				has_country_flag = lrsk_fedfix_tag_militarist
				has_country_flag = lrsk_fedfix_tag_materialist
			} }
			federation = { every_member = {
				limit = {
					OR = {
						has_origin = origin_common_ground_npc
						has_origin = origin_hegemon_npc
					}
					NOT = { has_country_flag = lrsk_fed_npc_fixed }
				}

				# force remove all ethics
				country_remove_ethic = ethic_pacifist
				country_remove_ethic = ethic_fanatic_pacifist
				country_remove_ethic = ethic_militarist
				country_remove_ethic = ethic_fanatic_militarist
				country_remove_ethic = ethic_materialist
				country_remove_ethic = ethic_fanatic_materialist
				country_remove_ethic = ethic_spiritualist
				country_remove_ethic = ethic_fanatic_spiritualist
				country_remove_ethic = ethic_egalitarian
				country_remove_ethic = ethic_fanatic_egalitarian
				country_remove_ethic = ethic_authoritarian
				country_remove_ethic = ethic_fanatic_authoritarian
				country_remove_ethic = ethic_xenophile
				country_remove_ethic = ethic_fanatic_xenophile
				country_remove_ethic = ethic_xenophobe
				country_remove_ethic = ethic_fanatic_xenophobe

				IF = { limit = { root = { has_country_flag = lrsk_fedfix_tag_pacifist } }
					country_add_ethic = ethic_xenophile
					country_add_ethic = ethic_fanatic_pacifist
				}
				IF = { limit = { root = { has_country_flag = lrsk_fedfix_tag_spiritualist } }
					country_add_ethic = ethic_xenophile
					country_add_ethic = ethic_fanatic_spiritualist
				}
				IF = { limit = { root = { has_country_flag = lrsk_fedfix_tag_militarist } }
					country_add_ethic = ethic_xenophile
					country_add_ethic = ethic_fanatic_militarist
				}
				IF = { limit = { root = { has_country_flag = lrsk_fedfix_tag_materialist } }
					country_add_ethic = ethic_xenophile
					country_add_ethic = ethic_fanatic_materialist
				}
						
				change_government = {
					civics = random
				}
				set_name = random

				set_country_flag = lrsk_fed_npc_fixed
			} }
		}
	}
}