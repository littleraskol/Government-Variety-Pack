# Government Variety Pack
# Events - Backend
# Author: littleraskol

# These events serve some general utility function.

namespace = lrsk_government_variety_pack_backend

# Adds a flag denoting this mod is in use, starts up mod-added origins.
event = {
	id = lrsk_government_variety_pack_backend.1
	hide_window = yes
	is_triggered_only = yes
	
	#trigger = { NOT = { has_global_flag = lrsk_government_variety_pack_mod_active } } 
	
	immediate = {
		set_global_flag = lrsk_government_variety_pack_mod_active
		
		## Origins Setup

		# Galactic Backdoor
		every_playable_country = {
			limit = { has_origin = lrsk_gov_var_origin_galactic_backdoor }
			country_event = { id = lrsk_gov_var_galactic_backdoor.1 }
		}
		
		# Shroud-Touched
		every_playable_country = {
			limit = { has_origin = lrsk_gov_var_origin_shroud_touched }
			country_event = { id = lrsk_gov_var_shroud_touched.1 }
		}
		
		# For Discovery / Tradeways / Grand Alliance
		every_playable_country = {
			limit = { OR = { 
				has_origin = lrsk_gov_var_origin_for_discovery
				has_origin = lrsk_gov_var_origin_for_discovery_mi
				has_origin = lrsk_gov_var_origin_tradeways
				has_origin = lrsk_gov_var_origin_tradeways_mc
				has_origin = lrsk_gov_var_origin_grand_alliance
			} }
			country_event = { id = lrsk_gov_var_new_fed_starts.1 }
		}
	}
}

# Fix for other mods possibly removing deposits. Should avoid the need for compatibility patches, etc.
# Every event that adds a starting planetary feature to the capital should call this to run after 2 days.
country_event = {
	id = lrsk_government_variety_pack_backend.2
	is_triggered_only = yes
	hide_window = yes

	# Structurally, this trigger is set up to facilitate adding "origin + flag" blocks. May be logically redundant but better safe than sorry...
	# Flags referred to here may not be used elsewhere but are pre-emptively checked in case I ever decide to add deposit-removing events, etc.
	trigger = {
		OR = {
			AND = {
				has_origin = lrsk_gov_var_origin_shroud_touched
				NOT = { has_country_flag = lrsk_gov_var_shroud_touched_lost_otherworld_pockets }
			}
			# Add other checks as needed...
		}
	}

	immediate = {
		# Most of these will check on capitals, since that's the most likely place for mod-added features.
		capital_scope = {
			switch = {
				trigger = has_planet_flag
				# Restore Otherworld Pockets if removed
				lrsk_gov_var_shroud_touched_capital = {
					IF = { limit = { NOT = { has_deposit = d_lrsk_gov_var_shroud_pockets } }
						add_deposit = d_lrsk_gov_var_shroud_pockets
					}
				}
				# Add other planet flags as needed...
			}
		}
	}
}

# Make sure that for origins that spawn new nearby empires, unlikely to be boxed in completely
country_event = {
	id = lrsk_government_variety_pack_backend.3
	is_triggered_only = yes
	hide_window = yes

	trigger = {
		OR = {
			has_origin = lrsk_gov_var_origin_for_discovery
			has_origin = lrsk_gov_var_origin_for_discovery_mi
			has_origin = lrsk_gov_var_origin_tradeways
			has_origin = lrsk_gov_var_origin_tradeways_mc
			has_origin = lrsk_gov_var_origin_grand_alliance
			#has_origin = lrsk_gov_var_origin_uplift 			# very unlikely but eh
			#has_origin = lrsk_gov_var_origin_sublight_empire
			#has_origin = lrsk_gov_var_origin_sublight_commonwealth
			#has_origin = lrsk_gov_var_origin_other
		}
	}
	
	immediate = {
		if = {
			limit = {
				capital_scope = {
					solar_system = {
						NOT = {
							any_neighbor_system = {
								NOT = { exists = owner }
							}
						}
					}
				}
			}
			if = {
				limit = {
					any_system = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 1
							max_distance <= 15
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
				}
				random_system = {
					limit = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 1
							max_distance <= 15
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
					save_event_target_as = lrsk_hyperlane_system_1
					add_hyperlane = {
						from = this
						to = root.capital_scope.solar_system
					}
				}
			}
			else_if = {
				limit = {
					any_system = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 15
							max_distance <= 20
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
				}
				random_system = {
					limit = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 15
							max_distance <= 20
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
					save_event_target_as = lrsk_hyperlane_system_1
					add_hyperlane = {
						from = this
						to = root.capital_scope.solar_system
					}
				}
			}
			else_if = {
				limit = {
					any_system = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 20
							max_distance <= 25
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
				}
				random_system = {
					limit = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 20
							max_distance <= 25
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
					save_event_target_as = lrsk_hyperlane_system_1
					add_hyperlane = {
						from = this
						to = root.capital_scope.solar_system
					}
				}
			}
			else_if = {
				limit = {
					any_system = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 25
							max_distance <= 40
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
				}
				random_system = {
					limit = {
						distance = {
							source = root.capital_scope.solar_system
							type = euclidean
							min_distance >= 25
							max_distance <= 40
						}
						NOT = { has_hyperlane_to = root.capital_scope.solar_system }
						NOT = { exists = owner }
					}
					save_event_target_as = lrsk_hyperlane_system_1
					add_hyperlane = {
						from = this
						to = root.capital_scope.solar_system
					}
				}
			}
			if = { limit = { exists = event_target:lrsk_hyperlane_system_1 }
				event_target:lrsk_hyperlane_system_1 = {
					if = { limit = { NOT = { any_neighbor_system = { NOT = { exists = owner } } } }
						if = {
							limit = { any_system = {
								distance = {
									source = event_target:lrsk_hyperlane_system_1
									type = euclidean
									min_distance >= 1
									max_distance <= 25
								}
								NOT = { has_hyperlane_to = event_target:lrsk_hyperlane_system_1 }
								NOT = { exists = owner }
							} }
							random_system = {
								limit = { 
									distance = {
										source = event_target:lrsk_hyperlane_system_1
										type = euclidean
										min_distance >= 1
										max_distance <= 25
									}
									NOT = { has_hyperlane_to = this }
									NOT = { exists = owner }
								}
								save_event_target_as = lrsk_hyperlane_system_2
								add_hyperlane = {
									from = this
									to = event_target:lrsk_hyperlane_system_1
								}
							}
						}
						else_if = {
							limit = { any_system = {
								distance = {
									source = event_target:lrsk_hyperlane_system_1
									type = euclidean
									min_distance > 25
									max_distance <= 50
								}
								NOT = { has_hyperlane_to = event_target:lrsk_hyperlane_system_1 }
								NOT = { exists = owner }
							} }
							random_system = {
								limit = { 
									distance = {
										source = event_target:lrsk_hyperlane_system_1
										type = euclidean
										min_distance > 25
										max_distance <= 50
									}
									NOT = { has_hyperlane_to = event_target:lrsk_hyperlane_system_1 }
									NOT = { exists = owner }
								}
								save_event_target_as = lrsk_hyperlane_system_2
								add_hyperlane = {
									from = this
									to = event_target:lrsk_hyperlane_system_1
								}
							}
						}					
					}
				}
			}
			if = { limit = { exists = event_target:lrsk_hyperlane_system_2 }
				event_target:lrsk_hyperlane_system_2 = {
					if = { limit = { NOT = { any_neighbor_system = { NOT = { exists = owner } } } }
						if = {
							limit = { any_system = {
								distance = {
									source = event_target:lrsk_hyperlane_system_2
									type = euclidean
									min_distance >= 1
									max_distance <= 25
								}
								NOT = { has_hyperlane_to = event_target:lrsk_hyperlane_system_2 }
								NOT = { exists = owner }
							} }
							random_system = {
								limit = { 
									distance = {
										source = event_target:lrsk_hyperlane_system_2
										type = euclidean
										min_distance >= 1
										max_distance <= 25
									}
									NOT = { has_hyperlane_to = this }
									NOT = { exists = owner }
								}
								save_event_target_as = lrsk_hyperlane_system_3
								add_hyperlane = {
									from = this
									to = event_target:lrsk_hyperlane_system_1
								}
							}
						}
					}
				}					
			}
		}
	}
}

}
